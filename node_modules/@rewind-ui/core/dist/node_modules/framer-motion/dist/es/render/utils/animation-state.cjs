"use strict";var e=require("../../animation/utils/is-animation-controls.cjs"),t=require("../../animation/utils/is-keyframes-target.cjs"),i=require("../../utils/shallow-compare.cjs"),n=require("./is-variant-label.cjs"),r=require("./resolve-dynamic-variants.cjs"),a=require("./variant-props.cjs"),o=require("../../animation/interfaces/visual-element.cjs");const s=[...a.variantPriorityOrder].reverse(),l=a.variantPriorityOrder.length;function c(e){return t=>Promise.all(t.map((({animation:t,options:i})=>o.animateVisualElement(e,t,i))))}function u(e,t){return"string"==typeof t?t!==e:!!Array.isArray(t)&&!i.shallowCompare(t,e)}function v(e=!1){return{isActive:e,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}exports.checkVariantsDidChange=u,exports.createAnimationState=function(a){let o=c(a);const m={animate:v(!0),whileInView:v(),whileHover:v(),whileTap:v(),whileDrag:v(),whileFocus:v(),exit:v()};let p=!0;const d=(e,t)=>{const i=r.resolveVariant(a,t);if(i){const{transition:t,transitionEnd:n,...r}=i;e={...e,...r,...n}}return e};function f(r,c){const v=a.getProps(),f=a.getVariantContext(!0)||{},y=[],A=new Set;let h={},g=1/0;for(let o=0;o<l;o++){const l=s[o],w=m[l],P=void 0!==v[l]?v[l]:f[l],V=n.isVariantLabel(P),j=l===c?w.isActive:null;!1===j&&(g=o);let q=P===f[l]&&P!==v[l]&&V;if(q&&p&&a.manuallyAnimateOnMount&&(q=!1),w.protectedKeys={...h},!w.isActive&&null===j||!P&&!w.prevProp||e.isAnimationControls(P)||"boolean"==typeof P)continue;const C=u(w.prevProp,P);let K=C||l===c&&w.isActive&&!q&&V||o>g&&V;const O=Array.isArray(P)?P:[P];let b=O.reduce(d,{});!1===j&&(b={});const{prevResolvedValues:x={}}=w,E={...x,...b},S=e=>{K=!0,A.delete(e),w.needsAnimating[e]=!0};for(const e in E){const n=b[e],r=x[e];h.hasOwnProperty(e)||(n!==r?t.isKeyframesTarget(n)&&t.isKeyframesTarget(r)?!i.shallowCompare(n,r)||C?S(e):w.protectedKeys[e]=!0:void 0!==n?S(e):A.add(e):void 0!==n&&A.has(e)?S(e):w.protectedKeys[e]=!0)}w.prevProp=P,w.prevResolvedValues=b,w.isActive&&(h={...h,...b}),p&&a.blockInitialAnimation&&(K=!1),K&&!q&&y.push(...O.map((e=>({animation:e,options:{type:l,...r}}))))}if(A.size){const e={};A.forEach((t=>{const i=a.getBaseTarget(t);void 0!==i&&(e[t]=i)})),y.push({animation:e})}let w=Boolean(y.length);return p&&!1===v.initial&&!a.manuallyAnimateOnMount&&(w=!1),p=!1,w?o(y):Promise.resolve()}return{animateChanges:f,setActive:function(e,t,i){var n;if(m[e].isActive===t)return Promise.resolve();null===(n=a.variantChildren)||void 0===n||n.forEach((i=>{var n;return null===(n=i.animationState)||void 0===n?void 0:n.setActive(e,t)})),m[e].isActive=t;const r=f(i,e);for(const e in m)m[e].protectedKeys={};return r},setAnimateFunction:function(e){o=e(a)},getState:()=>m}};
