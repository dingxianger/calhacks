import{keyframes as e}from"../../generators/keyframes.js";import{spring as t}from"../../generators/spring/index.js";import{inertia as n}from"../../generators/inertia.js";import{frameloopDriver as r}from"./driver-frameloop.js";import{interpolate as l}from"../../../utils/interpolate.js";import{clamp as o}from"../../../utils/clamp.js";import{millisecondsToSeconds as a,secondsToMilliseconds as i}from"../../../utils/time-conversion.js";import{calcGeneratorDuration as s}from"../../generators/utils/calc-duration.js";const u={decay:n,inertia:n,tween:e,keyframes:e,spring:t};function m({autoplay:t=!0,delay:n=0,driver:m=r,keyframes:c,type:p="keyframes",repeat:d=0,repeatDelay:f=0,repeatType:y="loop",onPlay:h,onStop:v,onComplete:g,onUpdate:j,...k}){let D,M,w=1,x=!1;const P=()=>{D&&D(),M=new Promise((e=>{D=e}))};let b;P();const B=u[p]||e;let C;B!==e&&"number"!=typeof c[0]&&(C=l([0,100],c,{clamp:!1}),c=[0,100]);const S=B({...k,keyframes:c});let T;"mirror"===y&&(T=B({...k,keyframes:[...c].reverse(),velocity:-(k.velocity||0)}));let U="idle",q=null,z=null,A=null;null===S.calculatedDuration&&d&&(S.calculatedDuration=s(S));const{calculatedDuration:E}=S;let F=1/0,G=1/0;null!==E&&(F=E+f,G=F*(d+1)-f);let H=0;const I=e=>{if(null===z)return;w>0&&(z=Math.min(z,e)),w<0&&(z=Math.min(e-G/w,z)),H=null!==q?q:Math.round(e-z)*w;const t=H-n*(w>=0?1:-1),r=w>=0?t<0:t>G;H=Math.max(t,0),"finished"===U&&null===q&&(H=G);let l=H,a=S;if(d){const e=H/F;let t=Math.floor(e),n=e%1;!n&&e>=1&&(n=1),1===n&&t--,t=Math.min(t,d+1);const r=Boolean(t%2);r&&("reverse"===y?(n=1-n,f&&(n-=f/F)):"mirror"===y&&(a=T));let i=o(0,1,n);H>G&&(i="reverse"===y&&r?1:0),l=i*F}const i=r?{done:!1,value:c[0]}:a.next(l);C&&(i.value=C(i.value));let{done:s}=i;r||null===E||(s=w>=0?H>=G:H<=0);const u=null===q&&("finished"===U||"running"===U&&s);return j&&j(i.value),u&&L(),i},J=()=>{b&&b.stop(),b=void 0},K=()=>{U="idle",J(),P(),z=A=null},L=()=>{U="finished",g&&g(),J(),P()},N=()=>{if(x)return;b||(b=m(I));const e=b.now();h&&h(),null!==q?z=e-q:z&&"finished"!==U||(z=e),A=z,q=null,U="running",b.start()};t&&N();const O={then:(e,t)=>M.then(e,t),get time(){return a(H)},set time(e){e=i(e),H=e,null===q&&b&&0!==w?z=b.now()-e/w:q=e},get duration(){const e=null===S.calculatedDuration?s(S):S.calculatedDuration;return a(e)},get speed(){return w},set speed(e){e!==w&&b&&(w=e,O.time=a(H))},get state(){return U},play:N,pause:()=>{U="paused",q=H},stop:()=>{x=!0,"idle"!==U&&(U="idle",v&&v(),K())},cancel:()=>{null!==A&&I(A),K()},complete:()=>{U="finished"},sample:e=>(z=0,I(e))};return O}export{m as animateValue};
