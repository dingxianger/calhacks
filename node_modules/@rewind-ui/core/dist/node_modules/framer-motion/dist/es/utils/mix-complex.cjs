"use strict";var e=require("./mix.cjs"),r=require("./mix-color.cjs"),o=require("./pipe.cjs"),t=require("./errors.cjs"),n=require("../value/types/color/index.cjs"),s=require("../value/types/complex/index.cjs");const a=(e,r)=>o=>`${o>0?r:e}`;function u(o,t){return"number"==typeof o?r=>e.mix(o,t,r):n.color.test(o)?r.mixColor(o,t):o.startsWith("var(")?a(o,t):l(o,t)}const i=(e,r)=>{const o=[...e],t=o.length,n=e.map(((e,o)=>u(e,r[o])));return e=>{for(let r=0;r<t;r++)o[r]=n[r](e);return o}},l=(e,r)=>{const n=s.complex.createTransformer(r),u=s.analyseComplexValue(e),l=s.analyseComplexValue(r);return u.numVars===l.numVars&&u.numColors===l.numColors&&u.numNumbers>=l.numNumbers?o.pipe(i(u.values,l.values),n):(t.warning(!0,`Complex values '${e}' and '${r}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),a(e,r))};exports.mixArray=i,exports.mixComplex=l,exports.mixObject=(e,r)=>{const o={...e,...r},t={};for(const n in o)void 0!==e[n]&&void 0!==r[n]&&(t[n]=u(e[n],r[n]));return e=>{for(const r in t)o[r]=t[r](e);return o}};
