import{isKeyframesTarget as t}from"../../../animation/utils/is-keyframes-target.js";import{invariant as e}from"../../../utils/errors.js";import{transformPropOrder as r}from"../../html/utils/transform.js";import{findDimensionValueType as s}from"../value-types/dimensions.js";import{isBrowser as o}from"../../../utils/is-browser.js";import{number as a}from"../../../value/types/numbers/index.js";import{px as n}from"../../../value/types/numbers/units.js";const i=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),l=t=>i.has(t),m=t=>t===a||t===n,p=(t,e)=>parseFloat(t.split(", ")[e]),f=(t,e)=>(r,{transform:s})=>{if("none"===s||!s)return 0;const o=s.match(/^matrix3d\((.+)\)$/);if(o)return p(o[1],e);{const e=s.match(/^matrix\((.+)\)$/);return e?p(e[1],t):0}},u=new Set(["x","y","z"]),c=r.filter((t=>!u.has(t)));const h={width:({x:t},{paddingLeft:e="0",paddingRight:r="0"})=>t.max-t.min-parseFloat(e)-parseFloat(r),height:({y:t},{paddingTop:e="0",paddingBottom:r="0"})=>t.max-t.min-parseFloat(e)-parseFloat(r),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:f(4,13),y:f(5,14)},d=(r,a,i={},p={})=>{a={...a},p={...p};const f=Object.keys(a).filter(l);let u=[],d=!1;const g=[];if(f.forEach((o=>{const l=r.getValue(o);if(!r.hasValue(o))return;let f=i[o],h=s(f);const y=a[o];let x;if(t(y)){const t=y.length,r=null===y[0]?1:0;f=y[r],h=s(f);for(let o=r;o<t&&null!==y[o];o++)x?e(s(y[o])===x,"All keyframes must be of the same type"):(x=s(y[o]),e(x===h||m(h)&&m(x),"Keyframes must be of the same dimension as the current value"))}else x=s(y);if(h!==x)if(m(h)&&m(x)){const t=l.get();"string"==typeof t&&l.set(parseFloat(t)),"string"==typeof y?a[o]=parseFloat(y):Array.isArray(y)&&x===n&&(a[o]=y.map(parseFloat))}else(null==h?void 0:h.transform)&&(null==x?void 0:x.transform)&&(0===f||0===y)?0===f?l.set(x.transform(f)):a[o]=h.transform(y):(d||(u=function(t){const e=[];return c.forEach((r=>{const s=t.getValue(r);void 0!==s&&(e.push([r,s.get()]),s.set(r.startsWith("scale")?1:0))})),e.length&&t.render(),e}(r),d=!0),g.push(o),p[o]=void 0!==p[o]?p[o]:a[o],l.jump(y))})),g.length){const t=g.indexOf("height")>=0?window.pageYOffset:null,e=((t,e,r)=>{const s=e.measureViewportBox(),o=e.current,a=getComputedStyle(o),{display:n}=a,i={};"none"===n&&e.setStaticValue("display",t.display||"block"),r.forEach((t=>{i[t]=h[t](s,a)})),e.render();const l=e.measureViewportBox();return r.forEach((r=>{const s=e.getValue(r);s&&s.jump(i[r]),t[r]=h[r](l,a)})),t})(a,r,g);return u.length&&u.forEach((([t,e])=>{r.getValue(t).set(e)})),r.render(),o&&null!==t&&window.scrollTo({top:t}),{target:e,transitionEnd:p}}return{target:a,transitionEnd:p}};function g(t,e,r,s){return(t=>Object.keys(t).some(l))(e)?d(t,e,r,s):{target:e,transitionEnd:s}}export{h as positionalValues,g as unitConversion};
