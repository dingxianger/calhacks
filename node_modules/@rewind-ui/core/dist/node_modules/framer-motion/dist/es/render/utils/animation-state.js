import{isAnimationControls as t}from"../../animation/utils/is-animation-controls.js";import{isKeyframesTarget as e}from"../../animation/utils/is-keyframes-target.js";import{shallowCompare as n}from"../../utils/shallow-compare.js";import{isVariantLabel as i}from"./is-variant-label.js";import{resolveVariant as o}from"./resolve-dynamic-variants.js";import{variantPriorityOrder as r}from"./variant-props.js";import{animateVisualElement as s}from"../../animation/interfaces/visual-element.js";const a=[...r].reverse(),l=r.length;function c(r){let c=function(t){return e=>Promise.all(e.map((({animation:e,options:n})=>s(t,e,n))))}(r);const u={animate:p(!0),whileInView:p(),whileHover:p(),whileTap:p(),whileDrag:p(),whileFocus:p(),exit:p()};let v=!0;const f=(t,e)=>{const n=o(r,e);if(n){const{transition:e,transitionEnd:i,...o}=n;t={...t,...o,...i}}return t};function d(o,s){const p=r.getProps(),d=r.getVariantContext(!0)||{},A=[],y=new Set;let h={},g=1/0;for(let c=0;c<l;c++){const l=a[c],w=u[l],P=void 0!==p[l]?p[l]:d[l],j=i(P),K=l===s?w.isActive:null;!1===K&&(g=c);let V=P===d[l]&&P!==p[l]&&j;if(V&&v&&r.manuallyAnimateOnMount&&(V=!1),w.protectedKeys={...h},!w.isActive&&null===K||!P&&!w.prevProp||t(P)||"boolean"==typeof P)continue;const b=m(w.prevProp,P);let x=b||l===s&&w.isActive&&!V&&j||c>g&&j;const C=Array.isArray(P)?P:[P];let E=C.reduce(f,{});!1===K&&(E={});const{prevResolvedValues:O={}}=w,R={...O,...E},S=t=>{x=!0,y.delete(t),w.needsAnimating[t]=!0};for(const t in R){const i=E[t],o=O[t];h.hasOwnProperty(t)||(i!==o?e(i)&&e(o)?!n(i,o)||b?S(t):w.protectedKeys[t]=!0:void 0!==i?S(t):y.add(t):void 0!==i&&y.has(t)?S(t):w.protectedKeys[t]=!0)}w.prevProp=P,w.prevResolvedValues=E,w.isActive&&(h={...h,...E}),v&&r.blockInitialAnimation&&(x=!1),x&&!V&&A.push(...C.map((t=>({animation:t,options:{type:l,...o}}))))}if(y.size){const t={};y.forEach((e=>{const n=r.getBaseTarget(e);void 0!==n&&(t[e]=n)})),A.push({animation:t})}let w=Boolean(A.length);return v&&!1===p.initial&&!r.manuallyAnimateOnMount&&(w=!1),v=!1,w?c(A):Promise.resolve()}return{animateChanges:d,setActive:function(t,e,n){var i;if(u[t].isActive===e)return Promise.resolve();null===(i=r.variantChildren)||void 0===i||i.forEach((n=>{var i;return null===(i=n.animationState)||void 0===i?void 0:i.setActive(t,e)})),u[t].isActive=e;const o=d(n,t);for(const t in u)u[t].protectedKeys={};return o},setAnimateFunction:function(t){c=t(r)},getState:()=>u}}function m(t,e){return"string"==typeof e?e!==t:!!Array.isArray(e)&&!n(e,t)}function p(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}export{m as checkVariantsDidChange,c as createAnimationState};
